{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The starting point is the following [example](https://github.com/AequilibraE/aequilibrae/blob/develop/docs/source/examples/assignment_workflows/plot_route_choice.py) from the Aequillibrae documentation:\n",
        "\n",
        "<details>\n"
      ],
      "id": "1f2fa7ba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# # Imports\n",
        "# from uuid import uuid4\n",
        "# from tempfile import gettempdir\n",
        "# from os.path import join\n",
        "# from aequilibrae.utils.create_example import create_example"
      ],
      "id": "31bf4b80",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# # sphinx_gallery_thumbnail_path = 'images/plot_route_choice_assignment.png'\n",
        "\n",
        "# # %%\n",
        "\n",
        "# # We create the example project inside our temp folder\n",
        "# fldr = join(gettempdir(), uuid4().hex)\n",
        "\n",
        "# project = create_example(fldr, \"coquimbo\")\n",
        "\n",
        "# # %%\n",
        "# import logging\n",
        "# import sys\n",
        "\n",
        "# # We the project opens, we can tell the logger to direct all messages to the terminal as well\n",
        "# logger = project.logger\n",
        "# stdout_handler = logging.StreamHandler(sys.stdout)\n",
        "# formatter = logging.Formatter(\"%(asctime)s;%(levelname)s ; %(message)s\")\n",
        "# stdout_handler.setFormatter(formatter)\n",
        "# logger.addHandler(stdout_handler)\n",
        "\n",
        "# # %%\n",
        "# # Route Choice\n",
        "# # ------------\n",
        "\n",
        "# # %%\n",
        "# import numpy as np\n",
        "\n",
        "# # %%\n",
        "# # Model parameters\n",
        "# # ~~~~~~~~~~~~~~~~\n",
        "# # We'll set the parameters for our route choice model. These are the parameters that will be used to calculate the\n",
        "# # utility of each path. In our example, the utility is equal to *theta* * distance\n",
        "# # And the path overlap factor (PSL) is equal to *beta*.\n",
        "\n",
        "# # Distance factor\n",
        "# theta = 0.00011\n",
        "\n",
        "# # PSL parameter\n",
        "# beta = 1.1\n",
        "\n",
        "# # %%\n",
        "# # Let's build all graphs\n",
        "# project.network.build_graphs()\n",
        "# # We get warnings that several fields in the project are filled with NaNs.\n",
        "# # This is true, but we won't use those fields.\n",
        "\n",
        "# # %%\n",
        "# # We grab the graph for cars\n",
        "# graph = project.network.graphs[\"c\"]\n",
        "\n",
        "# # %%\n",
        "# # We also see what graphs are available\n",
        "# project.network.graphs.keys()\n",
        "\n",
        "# od_pairs_of_interest = [(71645, 79385), (77011, 74089)]\n",
        "# nodes_of_interest = (71645, 74089, 77011, 79385)\n",
        "\n",
        "# # %%\n",
        "# # let's say that utility is just a function of distance\n",
        "# # So we build our *utility* field as the distance times theta\n",
        "# graph.network = graph.network.assign(utility=graph.network.distance * theta)\n",
        "\n",
        "# # %%\n",
        "# # Prepare the graph with all nodes of interest as centroids\n",
        "# graph.prepare_graph(np.array(nodes_of_interest))\n",
        "\n",
        "# # %%\n",
        "# # And set the cost of the graph the as the utility field just created\n",
        "# graph.set_graph(\"utility\")\n",
        "\n",
        "# # %%\n",
        "# # We allow flows through \"centroid connectors\" because our centroids are not really centroids\n",
        "# # If we have actual centroid connectors in the network (and more than one per centroid) , then we\n",
        "# # should remove them from the graph\n",
        "# graph.set_blocked_centroid_flows(False)\n",
        "\n",
        "# # %%\n",
        "# # Mock demand matrix\n",
        "# # ~~~~~~~~~~~~~~~~~~\n",
        "# # We'll create a mock demand matrix with demand `1` for every zone.\n",
        "# from aequilibrae.matrix import AequilibraeMatrix\n",
        "\n",
        "# names_list = [\"demand\", \"5x demand\"]\n",
        "\n",
        "# mat = AequilibraeMatrix()\n",
        "# mat.create_empty(zones=graph.num_zones, matrix_names=names_list, memory_only=True)\n",
        "# mat.index = graph.centroids[:]\n",
        "# mat.matrices[:, :, 0] = np.full((graph.num_zones, graph.num_zones), 10.0)\n",
        "# mat.matrices[:, :, 1] = np.full((graph.num_zones, graph.num_zones), 50.0)\n",
        "# mat.computational_view()\n",
        "\n",
        "# # %%\n",
        "# # Route Choice class\n",
        "# # ~~~~~~~~~~~~~~~~~~\n",
        "# # Here we'll construct and use the Route Choice class to generate our route sets\n",
        "# from aequilibrae.paths import RouteChoice\n",
        "\n",
        "# # %%\n",
        "# # This object construct might take a minute depending on the size of the graph due to the construction of the compressed\n",
        "# # link to network link mapping that's required.  This is a one time operation per graph and is cached. We need to\n",
        "# # supply a Graph and optionally a AequilibraeMatrix, if the matrix is not provided link loading cannot be preformed.\n",
        "# rc = RouteChoice(graph)\n",
        "# rc.add_demand(mat)\n",
        "\n",
        "# # %%\n",
        "# # Here we'll set the parameters of our set generation. There are two algorithms available: Link penalisation, or BFSLE\n",
        "# # based on the paper\n",
        "# # \"Route choice sets for very high-resolution data\" by Nadine Rieser-SchÃ¼ssler, Michael Balmer & Kay W. Axhausen (2013).\n",
        "# # https://doi.org/10.1080/18128602.2012.671383\n",
        "# #\n",
        "# # Our BFSLE implementation is slightly different and has extended to allow applying link penalisation as well. Every\n",
        "# # link in all routes found at a depth are penalised with the `penalty` factor for the next depth. So at a depth of 0 no\n",
        "# # links are penalised nor removed. At depth 1, all links found at depth 0 are penalised, then the links marked for\n",
        "# # removal are removed. All links in the routes found at depth 1 are then penalised for the next depth. The penalisation\n",
        "# # compounds. Pass set `penalty=1.0` to disable.\n",
        "# #\n",
        "# # To assist in filtering out bad results during the assignment, a `cutoff_prob` parameter can be provided to exclude\n",
        "# # routes from the path-sized logit model. The `cutoff_prob` is used to compute an inverse binary logit and obtain a max\n",
        "# # difference in utilities. If a paths total cost is greater than the minimum cost path in the route set plus the max\n",
        "# # difference, the route is excluded from the PSL calculations. The route is still returned, but with a probability of\n",
        "# # 0.0.\n",
        "# #\n",
        "# # The `cutoff_prob` should be in the range [0, 1]. It is then rescaled internally to [0.5, 1] as probabilities below 0.5\n",
        "# # produce negative differences in utilities. A higher `cutoff_prob` includes more routes. A value of `0.0` will only\n",
        "# # include the minimum cost route. A value of `1.0` includes all routes.\n",
        "# #\n",
        "# # It is highly recommended to set either `max_routes` or `max_depth` to prevent runaway results.\n",
        "\n",
        "# # %%\n",
        "# # rc.set_choice_set_generation(\"link-penalisation\", max_routes=5, penalty=1.02)\n",
        "# rc.set_choice_set_generation(\"bfsle\", max_routes=5)\n",
        "\n",
        "# # %%\n",
        "# # All parameters are optional, the defaults are:\n",
        "# print(rc.default_parameters)\n",
        "\n",
        "# # %%\n",
        "# # We can now perform a computation for single OD pair if we'd like. Here we do one between the first and last centroid\n",
        "# # as well an an assignment.\n",
        "# results = rc.execute_single(77011, 74089, demand=1.0)\n",
        "# print(results[0])\n",
        "\n",
        "# # %%\n",
        "# # Because we asked it to also perform an assignment we can access the various results from that\n",
        "# # The default return is a Pyarrow Table but Pandas is nicer for viewing.\n",
        "# res = rc.get_results().to_pandas()\n",
        "# res.head()\n",
        "\n",
        "\n",
        "# # %%\n",
        "# # let's define a function to plot assignment results\n",
        "\n",
        "\n",
        "# def plot_results(link_loads):\n",
        "#     import folium\n",
        "#     import geopandas as gpd\n",
        "\n",
        "#     link_loads = link_loads[[\"link_id\", \"demand_tot\"]]\n",
        "#     link_loads = link_loads[link_loads.demand_tot > 0]\n",
        "#     max_load = link_loads[\"demand_tot\"].max()\n",
        "#     links = gpd.GeoDataFrame(project.network.links.data, crs=4326)\n",
        "#     loaded_links = links.merge(link_loads, on=\"link_id\", how=\"inner\")\n",
        "\n",
        "#     loads_lyr = folium.FeatureGroup(\"link_loads\")\n",
        "\n",
        "#     # Maximum thickness we would like is probably a 10, so let's make sure we don't go over that\n",
        "#     factor = 10 / max_load\n",
        "\n",
        "#     # Let's create the layers\n",
        "#     for _, rec in loaded_links.iterrows():\n",
        "#         points = rec.geometry.wkt.replace(\"LINESTRING \", \"\").replace(\"(\", \"\").replace(\")\", \"\").split(\", \")\n",
        "#         points = \"[[\" + \"],[\".join([p.replace(\" \", \", \") for p in points]) + \"]]\"\n",
        "#         # we need to take from x/y to lat/long\n",
        "#         points = [[x[1], x[0]] for x in eval(points)]\n",
        "#         _ = folium.vector_layers.PolyLine(\n",
        "#             points,\n",
        "#             tooltip=f\"link_id: {rec.link_id}, Flow: {rec.demand_tot:.3f}\",\n",
        "#             color=\"red\",\n",
        "#             weight=factor * rec.demand_tot,\n",
        "#         ).add_to(loads_lyr)\n",
        "#     long, lat = project.conn.execute(\"select avg(xmin), avg(ymin) from idx_links_geometry\").fetchone()\n",
        "\n",
        "#     map_osm = folium.Map(location=[lat, long], tiles=\"Cartodb Positron\", zoom_start=12)\n",
        "#     loads_lyr.add_to(map_osm)\n",
        "#     folium.LayerControl().add_to(map_osm)\n",
        "#     return map_osm\n",
        "\n",
        "\n",
        "# # %%\n",
        "# plot_results(rc.get_load_results())\n",
        "\n",
        "# # %%\n",
        "# # To perform a batch operation we need to prepare the object first. We can either provide a list of tuple of the OD\n",
        "# # pairs we'd like to use, or we can provided a 1D list and the generation will be run on all permutations.\n",
        "# # rc.prepare(graph.centroids[:5])\n",
        "# rc.prepare()\n",
        "\n",
        "# # %%\n",
        "# # Now we can perform a batch computation with an assignment\n",
        "# rc.execute(perform_assignment=True)\n",
        "# res = rc.get_results().to_pandas()\n",
        "# res.head()\n",
        "\n",
        "# # %%\n",
        "# # Since we provided a matrix initially we can also perform link loading based on our assignment results.\n",
        "# rc.get_load_results()\n",
        "\n",
        "# # %% we can plot these as well\n",
        "# plot_results(rc.get_load_results())\n",
        "\n",
        "# # %%\n",
        "# # Select link analysis\n",
        "# # ~~~~~~~~~~~~~~~~~~~~\n",
        "# # We can also enable select link analysis by providing the links and the directions that we are interested in.  Here we\n",
        "# # set the select link to trigger when (7369, 1) and (20983, 1) is utilised in \"sl1\" and \"sl2\" when (7369, 1) is\n",
        "# # utilised.\n",
        "# rc.set_select_links({\"sl1\": [[(7369, 1), (20983, 1)]], \"sl2\": [(7369, 1)]})\n",
        "# rc.execute(perform_assignment=True)\n",
        "\n",
        "# # %%\n",
        "# # We can get then the results in a Pandas data frame for both the network.\n",
        "# sl = rc.get_select_link_loading_results()\n",
        "# sl\n",
        "\n",
        "# # %%\n",
        "# # We can also access the OD matrices for this link loading. These matrices are sparse and can be converted to\n",
        "# # scipy.sparse matrices for ease of use. They're stored in a dictionary where the key is the matrix name concatenated\n",
        "# # wit the select link set name via an underscore. These matrices are constructed during `get_select_link_loading_results`.\n",
        "# rc.get_select_link_od_matrix_results()\n",
        "\n",
        "# # %%\n",
        "# od_matrix = rc.get_select_link_od_matrix_results()[\"sl1\"][\"demand\"]\n",
        "# od_matrix.to_scipy().toarray()\n",
        "\n",
        "# # %%\n",
        "# project.close()"
      ],
      "id": "fa7eafaa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</details>"
      ],
      "id": "8a2738df"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/robin/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}